<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="refresh" content="3600" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Synced Eye</title>
  <style>
    html,body{margin:0;padding:0;width:100%;height:100%;background:#000;overflow:hidden}
    .hidden{display:none}
    video.loopVideo, img.loopVideo{
      position:fixed;top:50%;left:50%;width:100vw;height:100vh;transform:translate(-50%,-50%) rotate(180deg);
      object-fit:cover;z-index:0;background-color:black
    }
    #eye{position:fixed;width:600px;height:600px;background:#fff;border-radius:50%;overflow:hidden;
      transition:left 3s ease-in-out, top 3s ease-in-out;z-index:1}
    #pupil{position:absolute;width:300px;height:300px;background:#000;border-radius:50%;
      top:50%;left:50%;transform:translate(-50%,-50%);transition:left 3s ease-in-out, top 3s ease-in-out}
    #pupil::before{content:'';position:absolute;width:80px;height:80px;background:#fff;border-radius:50%;top:40px;left:40px}
    .eyelid{position:absolute;width:100%;height:50%;background:#000;left:0;z-index:3;pointer-events:none}
    #upperEyelid{top:-50%} #lowerEyelid{bottom:-50%}
    @keyframes blinkUpper{0%,100%{top:-50%}50%{top:0}} @keyframes blinkLower{0%,100%{bottom:-50%}50%{bottom:0}}
    .blinkUp{animation:blinkUpper 0.5s ease-in-out} .blinkDown{animation:blinkLower 0.5s ease-in-out}
    .sleepLid{position:fixed;width:600px;height:100px;background:#555;border-radius:50px;left:50%;top:50%;
      transform:translate(-50%,-50%);z-index:4;animation:floatSleep 4s ease-in-out infinite}
    @keyframes floatSleep{0%,100%{transform:translate(-50%,-35%)}50%{transform:translate(-50%,-65%)}}
    .bubble{position:fixed;border-radius:50%;background:rgba(255,255,255,.15);animation:bubbleUp 5s linear infinite;display:none;z-index:5}
    .showBubbles .bubble{display:block}
    #bubble1{width:40px;height:40px;left:85%;top:10%;animation-delay:0s}
    #bubble2{width:30px;height:30px;left:88%;top:16%;animation-delay:1.5s}
    #bubble3{width:20px;height:20px;left:91%;top:22%;animation-delay:3s}
    @keyframes bubbleUp{0%{transform:translateY(0);opacity:.2}50%{transform:translateY(-20px);opacity:.4}100%{transform:translateY(-60px);opacity:0}}
    #heart{position:fixed;font-size:300px;z-index:10;display:none;pointer-events:none;animation:pulse 1s infinite ease-in-out;
      text-align:center;line-height:600px;width:600px;height:600px;transform:rotate(180deg)}
    @keyframes pulse{0%,100%{transform:scale(1) rotate(180deg)}50%{transform:scale(1.2) rotate(180deg)}}
  </style>
</head>
<body>
  <div id="eye">
    <div id="pupil"></div>
    <div id="upperEyelid" class="eyelid"></div>
    <div id="lowerEyelid" class="eyelid"></div>
  </div>
  <div id="sleepEyelid" class="hidden"></div>
  <div id="bubble1" class="bubble"></div>
  <div id="bubble2" class="bubble"></div>
  <div id="bubble3" class="bubble"></div>
  <div id="heart">❤️</div>
  <video id="loopVideo" class="loopVideo hidden" muted autoplay playsinline preload="auto">
    <source id="videoSource" src="" type="video/mp4">
    Your browser does not support the video tag.
  </video>

  <script>
    (function () {
      // ------ DOM refs ------
      const eye = document.getElementById('eye');
      const pupil = document.getElementById('pupil');
      const upperLid = document.getElementById('upperEyelid');
      const lowerLid = document.getElementById('lowerEyelid');
      const sleepLid = document.getElementById('sleepEyelid');
      const heart = document.getElementById('heart');
      const loopVideo = document.getElementById('loopVideo');
      const videoSource = document.getElementById('videoSource');

      // ------ Day/time gating (local) ------
      const nowLocal = new Date();
      const day = nowLocal.getDay();
      const hour = nowLocal.getHours();
      const isGifDay = day === 0 || day === 1;
      const isSleeping = hour >= 1 && hour < 13;

      // ------ Deterministic PRNG (Mulberry32) ------
      function mulberry32(a) {
        return function() {
          let t = a += 0x6D2B79F5;
          t = Math.imul(t ^ (t >>> 15), t | 1);
          t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
          return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
      }

      // ------ Shared positions & timing ------
      const positions = [
        { x: 0.05, y: 0.05 },
        { x: 0.75, y: 0.20 },
        { x: 0.60, y: 0.60 },
        { x: 0.30, y: 0.70 },
        { x: 0.45, y: 0.45 },
      ];
      const STEP = 8000;
      const CYCLE = positions.length * STEP;

      // ------ Clock sync via WS ------
      let ws, wsUrl, prng = mulberry32(1), seed = 1;
      let offset = 0;           // serverTime - clientNow
      let epochStart = null;    // ms epoch boundary for position schedule
      let reconnectDelay = 500; // grows up to a cap

      function clientNow() { return Date.now(); }
      function syncedNow() { return clientNow() + offset; }

      function computeOffsetPing() {
        const t0 = clientNow();
        ws.send(JSON.stringify({ type: 'ping', echo: t0 }));
      }

      function connectWS() {
        const proto = location.protocol === 'https:' ? 'wss://' : 'ws://';
        // If server runs on same host: change :8080 if different.
        wsUrl = proto + (location.hostname || 'localhost') + ':8080';
        ws = new WebSocket(wsUrl);

        ws.onopen = () => {
          reconnectDelay = 500;
          // Initial ping for better offset after 'sync'
          computeOffsetPing();
        };

        ws.onmessage = (event) => {
          let data;
          try { data = JSON.parse(event.data); } catch { return; }

          if (data.type === 'sync') {
            // 1st sync from server: seed + epochStart + serverTime
            seed = data.seed >>> 0;
            prng = mulberry32(seed);
            epochStart = data.epochStart;
            // First rough offset
            offset = (data.serverTime - clientNow());
            // Start behaviors once we know epoch
            if (!(isGifDay || isSleeping)) startEyeBehavior(); else applyMode();
            return;
          }

          if (data.type === 'pong' && typeof data.echo === 'number') {
            const t1 = clientNow();
            const rtt = t1 - data.echo;
            // Better offset estimate: serverTime - (clientSend + rtt/2)
            offset = (data.serverTime - (data.echo + rtt / 2));
            return;
          }

          if (data.type === 'heartbeat') {
            // slowly correct drift toward heartbeat time (avoid jumps)
            const targetOffset = data.serverTime - clientNow();
            offset = offset * 0.9 + targetOffset * 0.1;
            return;
          }

          // Optional shared events (manual blink/move) — kept for parity
          if (data.type === 'blink') blink(true);
          if (data.type === 'move' && data.position) moveTo(data.position, true);
        };

        ws.onclose = scheduleReconnect;
        ws.onerror = scheduleReconnect;
      }

      function scheduleReconnect() {
        try { ws && ws.close(); } catch {}
        setTimeout(connectWS, reconnectDelay);
        reconnectDelay = Math.min(reconnectDelay * 1.6, 5000);
      }

      // Broadcast helper (safe if ws not ready)
      function broadcast(evt) {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify(evt));
        }
      }

      // ------ Eye behavior (driven by synced clock) ------
      let moveTimer = null, blinkTimer = null, heartTimer = null;

      function applyMode() {
        if (isGifDay) {
          const gif = document.createElement('img');
          gif.src = "omer1.gif";
          gif.classList.add('loopVideo');
          document.body.appendChild(gif);
          eye.classList.add('hidden');
        } else if (isSleeping) {
          eye.classList.add('hidden');
          sleepLid.classList.remove('hidden');
          sleepLid.classList.add('sleepLid');
          document.body.classList.add('showBubbles');
        }
      }

      function startEyeBehavior() {
        eye.classList.remove('hidden');
        scheduleNextMoveTick(true);
        scheduleNextBlink();
        scheduleNextHeart();
      }

      function positionIndexAt(timeMs) {
        // Use shared epochStart so everyone aligns to same slot
        const t = (timeMs - epochStart + CYCLE * 1000) % CYCLE; // big offset to avoid negatives
        return Math.floor(t / STEP) % positions.length;
      }

      function moveTo(p, fromSocket = false) {
        const eyeW = eye.offsetWidth, eyeH = eye.offsetHeight;
        const maxX = window.innerWidth - eyeW, maxY = window.innerHeight - eyeH;
        const tx = Math.max(0, Math.min(p.x * window.innerWidth, maxX));
        const ty = Math.max(0, Math.min(p.y * window.innerHeight, maxY));
        eye.style.left = tx + 'px';
        eye.style.top = ty + 'px';
        pupil.style.left = p.x > 0.5 ? '80%' : '20%';
        pupil.style.top  = p.y > 0.5 ? '80%' : '20%';
        setTimeout(() => { pupil.style.left = '50%'; pupil.style.top = '50%'; }, 3000);
        if (!fromSocket) broadcast({ type: 'move', position: p });
      }

      function scheduleNextMoveTick(initial=false) {
        if (moveTimer) clearTimeout(moveTimer);
        const nowS = syncedNow();
        const idx = positionIndexAt(nowS);
        moveTo(positions[idx], true); // fromSocket=true to avoid rebroadcast storms

        // Schedule precisely at next STEP boundary to minimize drift
        const nextBoundary = epochStart + (Math.floor((nowS - epochStart) / STEP) + 1) * STEP;
        const delay = Math.max(0, nextBoundary - nowS);
        moveTimer = setTimeout(scheduleNextMoveTick, delay);
      }

      // ---- Deterministic blink schedule (seeded) ----
      function nextDeterministicDelay(baseMin, baseMax, channelSalt) {
        // channelSalt makes blink vs heart run on different PRNG substreams
        const salt = (seed ^ channelSalt) >>> 0;
        const localPrng = mulberry32(salt + Math.floor((syncedNow() - epochStart) / (baseMin + 1)));
        const r = localPrng();
        return baseMin + r * (baseMax - baseMin);
      }

      function blink(fromSocket = false) {
        upperLid.classList.add('blinkUp');
        lowerLid.classList.add('blinkDown');
        setTimeout(() => {
          upperLid.classList.remove('blinkUp');
          lowerLid.classList.remove('blinkDown');
        }, 500);
        if (!fromSocket) broadcast({ type: 'blink' });
      }

      function scheduleNextBlink() {
        if (blinkTimer) clearTimeout(blinkTimer);
        blink(); // blink now, then schedule the next deterministically
        const delay = nextDeterministicDelay(5000, 10000, 0xB1_1NK);
        blinkTimer = setTimeout(scheduleNextBlink, delay);
      }

      // ---- Deterministic heart schedule (seeded) ----
      function showHeartTemporarily() {
        const heartDuration = 2000;
        const eyeBox = eye.getBoundingClientRect();
        heart.style.left = eyeBox.left + 'px';
        heart.style.top = eyeBox.top + 'px';
        heart.style.display = 'block';
        eye.style.visibility = 'hidden';
        setTimeout(() => {
          heart.style.display = 'none';
          eye.style.visibility = 'visible';
          scheduleNextHeart();
        }, heartDuration);
      }

      function scheduleNextHeart() {
        if (heartTimer) clearTimeout(heartTimer);
        const delay = nextDeterministicDelay(10000, 30000, 0xHE_ART);
        heartTimer = setTimeout(showHeartTemporarily, delay);
      }

      // ------ Mode + start ------
      if (isGifDay || isSleeping) {
        applyMode();
      }

      connectWS();

      // Keep page flip timing aligned with the sleep/wake boundaries
      function scheduleTargetRefresh() {
        const now = new Date();
        const next01 = new Date(now); next01.setHours(1, 1, 0, 0);
        const next13 = new Date(now); next13.setHours(13, 1, 0, 0);
        if (next01 <= now) next01.setDate(next01.getDate() + 1);
        if (next13 <= now) next13.setDate(next13.getDate() + 1);
        const nextTarget = next01 < next13 ? next01 : next13;
        setTimeout(() => location.reload(), nextTarget - now);
      }
      scheduleTargetRefresh();
      setInterval(() => location.reload(), 3600 * 1000);

      // Recompute layout (keeps eye in bounds on resize)
      window.addEventListener('resize', () => {
        const nowS = syncedNow();
        if (epochStart != null) moveTo(positions[positionIndexAt(nowS)], true);
      });

      // Optional: Manual blink on click (broadcasts)
      window.addEventListener('click', () => blink(false));
    })();
  </script>
</body>
</html>
